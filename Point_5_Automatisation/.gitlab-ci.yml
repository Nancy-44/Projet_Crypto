stages:
  - build
  - push
  - deploy

image: docker:24
services:
  - docker:24-dind

variables:
  DOCKER_HOST: tcp://docker:2375
  DOCKER_TLS_CERTDIR: ""
  DOCKER_DRIVER: overlay2

before_script:
  # Charger variables du .env
  - if [ -f .env ]; then set -o allexport; source .env; set +o allexport; fi
  # Login Docker
  - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" --password-stdin "$CI_REGISTRY"

# -------- BUILD --------
build_api:
  stage: build
  script:
    - docker build -t $CI_REGISTRY_IMAGE/api:latest ./api
    - docker push $CI_REGISTRY_IMAGE/api:latest
  only:
    - main

build_etl:
  stage: build
  script:
    - docker build -t $CI_REGISTRY_IMAGE/etl:latest ./etl
    - docker push $CI_REGISTRY_IMAGE/etl:latest
  only:
    - main

build_streaming:
  stage: build
  script:
    - docker build -t $CI_REGISTRY_IMAGE/streaming:latest ./streaming
    - docker push $CI_REGISTRY_IMAGE/streaming:latest
  only:
    - main

build_ml:
  stage: build
  script:
    - docker build -t $CI_REGISTRY_IMAGE/ml:latest ./ml
    - docker push $CI_REGISTRY_IMAGE/ml:latest
  only:
    - main

# -------- PUSH --------
# Ici, on “valide” les pushes ou on pourrait les retagger pour un autre registry
push_images:
  stage: push
  script:
    - docker pull $CI_REGISTRY_IMAGE/api:latest
    - docker pull $CI_REGISTRY_IMAGE/etl:latest
    - docker pull $CI_REGISTRY_IMAGE/streaming:latest
    - docker pull $CI_REGISTRY_IMAGE/ml:latest
  needs:
    - build_api
    - build_etl
    - build_streaming
    - build_ml
  only:
    - main

# -------- DEPLOY --------
deploy:
  stage: deploy
  script:
    - docker compose -f docker-compose.yml pull
    - docker compose -f docker-compose.yml up -d
  only:
    - main
  environment:
    name: production

